/**
 * Sermon Helper Outline Logic Tests
 *
 * Tests for the SermonHelperOutline component business logic.
 * These tests verify element CRUD operations, reordering, and Markdown export.
 *
 * IMPORTANT: Do not move web/UI tests into packages/types.
 * If apps/web lacks a test harness, set one up instead of using
 * packages/types as a dumping ground. packages/types is reserved
 * for shared types and schemas only.
 */

import { describe, it, expect, beforeEach } from '@jest/globals';
import type { SermonElement } from '@elder-first/types';

// Type definitions matching the component
type SermonElementType = SermonElement['type'];

// Mock generateId for testing (component uses crypto.randomUUID())
let mockIdCounter = 0;
function mockGenerateId(): string {
  return `mock-uuid-${++mockIdCounter}`;
}

// Reset counter before each test
beforeEach(() => {
  mockIdCounter = 0;
});

/**
 * Create a new element (mirrors component logic from SermonHelperOutline.tsx)
 */
function createElement(type: SermonElementType): SermonElement {
  const id = mockGenerateId();

  switch (type) {
    case 'section':
      return { id, type: 'section', title: '' };
    case 'point':
      return { id, type: 'point', text: '' };
    case 'note':
      return { id, type: 'note', text: '' };
    case 'scripture':
      return { id, type: 'scripture', reference: '', note: '' };
    case 'hymn':
      return { id, type: 'hymn', hymnId: mockGenerateId(), title: '', note: '' };
    default:
      throw new Error(`Unknown element type: ${type}`);
  }
}

/**
 * Update an element in the array (mirrors component logic)
 * Uses type assertion since we know the partial updates are valid for the specific element type
 */
function updateElement(
  elements: SermonElement[],
  id: string,
  updates: Record<string, unknown>
): SermonElement[] {
  return elements.map((el) =>
    el.id === id ? ({ ...el, ...updates } as SermonElement) : el
  );
}

/**
 * Delete an element from the array (mirrors component logic)
 */
function deleteElement(elements: SermonElement[], id: string): SermonElement[] {
  return elements.filter((el) => el.id !== id);
}

/**
 * Move element up in the array (mirrors component logic)
 */
function moveUp(elements: SermonElement[], index: number): SermonElement[] {
  if (index === 0) return elements;
  const newElements = [...elements];
  [newElements[index - 1], newElements[index]] = [newElements[index], newElements[index - 1]];
  return newElements;
}

/**
 * Move element down in the array (mirrors component logic)
 */
function moveDown(elements: SermonElement[], index: number): SermonElement[] {
  if (index === elements.length - 1) return elements;
  const newElements = [...elements];
  [newElements[index], newElements[index + 1]] = [newElements[index + 1], newElements[index]];
  return newElements;
}

/**
 * Export outline to Markdown (mirrors component logic)
 */
function exportToMarkdown(elements: SermonElement[], sermonTitle: string): string {
  let md = `# ${sermonTitle}\n\n`;
  md += `## Sermon Outline\n\n`;

  for (const el of elements) {
    switch (el.type) {
      case 'section':
        md += `### ${el.title}\n\n`;
        break;
      case 'point':
        md += `- **Point:** ${el.text}\n`;
        break;
      case 'note':
        md += `- *Note:* ${el.text}\n`;
        break;
      case 'scripture':
        md += `- **Scripture:** ${el.reference}`;
        if (el.note) md += ` — ${el.note}`;
        md += '\n';
        break;
      case 'hymn':
        md += `- **Hymn:** ${el.title}`;
        if (el.note) md += ` — ${el.note}`;
        md += '\n';
        break;
    }
  }

  md += '\n---\n*Generated by Elder-First Church Platform*\n';
  return md;
}

// =============================================================================
// TESTS
// =============================================================================

describe('SermonHelperOutline - Element Creation', () => {
  describe('createElement', () => {
    it('creates a section element with empty title', () => {
      const element = createElement('section');

      expect(element.type).toBe('section');
      expect(element.id).toBeDefined();
      if (element.type === 'section') {
        expect(element.title).toBe('');
      }
    });

    it('creates a point element with empty text', () => {
      const element = createElement('point');

      expect(element.type).toBe('point');
      if (element.type === 'point') {
        expect(element.text).toBe('');
      }
    });

    it('creates a note element with empty text', () => {
      const element = createElement('note');

      expect(element.type).toBe('note');
      if (element.type === 'note') {
        expect(element.text).toBe('');
      }
    });

    it('creates a scripture element with empty reference and note', () => {
      const element = createElement('scripture');

      expect(element.type).toBe('scripture');
      if (element.type === 'scripture') {
        expect(element.reference).toBe('');
        expect(element.note).toBe('');
      }
    });

    it('creates a hymn element with empty fields', () => {
      const element = createElement('hymn');

      expect(element.type).toBe('hymn');
      if (element.type === 'hymn') {
        expect(element.hymnId).toBeDefined();
        expect(element.title).toBe('');
        expect(element.note).toBe('');
      }
    });

    it('generates unique IDs for each element', () => {
      const el1 = createElement('section');
      const el2 = createElement('point');
      const el3 = createElement('note');

      expect(el1.id).not.toBe(el2.id);
      expect(el2.id).not.toBe(el3.id);
      expect(el1.id).not.toBe(el3.id);
    });
  });
});

describe('SermonHelperOutline - Element Updates', () => {
  it('updates a section title', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Old Title' },
    ];

    const updated = updateElement(elements, 'test-1', { title: 'New Title' });

    expect(updated[0].type).toBe('section');
    if (updated[0].type === 'section') {
      expect(updated[0].title).toBe('New Title');
    }
  });

  it('updates a point text', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'point', text: 'Old Text' },
    ];

    const updated = updateElement(elements, 'test-1', { text: 'New Text' });

    if (updated[0].type === 'point') {
      expect(updated[0].text).toBe('New Text');
    }
  });

  it('updates a scripture note without changing reference', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'scripture', reference: 'John 3:16', note: '' },
    ];

    const updated = updateElement(elements, 'test-1', { note: 'Key verse' });

    if (updated[0].type === 'scripture') {
      expect(updated[0].reference).toBe('John 3:16'); // Unchanged
      expect(updated[0].note).toBe('Key verse');
    }
  });

  it('does not modify other elements', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Section 1' },
      { id: 'test-2', type: 'point', text: 'Point 1' },
    ];

    const updated = updateElement(elements, 'test-1', { title: 'Updated' });

    expect(updated.length).toBe(2);
    if (updated[1].type === 'point') {
      expect(updated[1].text).toBe('Point 1'); // Unchanged
    }
  });

  it('returns same array if ID not found', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Section' },
    ];

    const updated = updateElement(elements, 'nonexistent', { title: 'Changed' });

    if (updated[0].type === 'section') {
      expect(updated[0].title).toBe('Section'); // Unchanged
    }
  });
});

describe('SermonHelperOutline - Element Deletion', () => {
  it('removes the specified element', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Section' },
      { id: 'test-2', type: 'point', text: 'Point' },
    ];

    const result = deleteElement(elements, 'test-1');

    expect(result.length).toBe(1);
    expect(result[0].id).toBe('test-2');
  });

  it('returns empty array when deleting only element', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Section' },
    ];

    const result = deleteElement(elements, 'test-1');

    expect(result.length).toBe(0);
  });

  it('returns same array if ID not found', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Section' },
    ];

    const result = deleteElement(elements, 'nonexistent');

    expect(result.length).toBe(1);
  });
});

describe('SermonHelperOutline - Element Reordering', () => {
  describe('moveUp', () => {
    it('moves element up one position', () => {
      const elements: SermonElement[] = [
        { id: 'test-1', type: 'section', title: 'First' },
        { id: 'test-2', type: 'section', title: 'Second' },
        { id: 'test-3', type: 'section', title: 'Third' },
      ];

      const result = moveUp(elements, 1);

      expect(result[0].id).toBe('test-2');
      expect(result[1].id).toBe('test-1');
      expect(result[2].id).toBe('test-3');
    });

    it('does not move first element', () => {
      const elements: SermonElement[] = [
        { id: 'test-1', type: 'section', title: 'First' },
        { id: 'test-2', type: 'section', title: 'Second' },
      ];

      const result = moveUp(elements, 0);

      expect(result[0].id).toBe('test-1');
      expect(result[1].id).toBe('test-2');
    });

    it('preserves element data when moving', () => {
      const elements: SermonElement[] = [
        { id: 'test-1', type: 'point', text: 'First Point' },
        { id: 'test-2', type: 'scripture', reference: 'John 3:16', note: 'Key' },
      ];

      const result = moveUp(elements, 1);

      if (result[0].type === 'scripture') {
        expect(result[0].reference).toBe('John 3:16');
        expect(result[0].note).toBe('Key');
      }
    });
  });

  describe('moveDown', () => {
    it('moves element down one position', () => {
      const elements: SermonElement[] = [
        { id: 'test-1', type: 'section', title: 'First' },
        { id: 'test-2', type: 'section', title: 'Second' },
        { id: 'test-3', type: 'section', title: 'Third' },
      ];

      const result = moveDown(elements, 1);

      expect(result[0].id).toBe('test-1');
      expect(result[1].id).toBe('test-3');
      expect(result[2].id).toBe('test-2');
    });

    it('does not move last element', () => {
      const elements: SermonElement[] = [
        { id: 'test-1', type: 'section', title: 'First' },
        { id: 'test-2', type: 'section', title: 'Second' },
      ];

      const result = moveDown(elements, 1);

      expect(result[0].id).toBe('test-1');
      expect(result[1].id).toBe('test-2');
    });
  });
});

describe('SermonHelperOutline - Export to Markdown', () => {
  it('includes sermon title as H1', () => {
    const md = exportToMarkdown([], 'My Test Sermon');

    expect(md).toContain('# My Test Sermon');
  });

  it('includes outline header as H2', () => {
    const md = exportToMarkdown([], 'Test');

    expect(md).toContain('## Sermon Outline');
  });

  it('formats sections as H3', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Introduction' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('### Introduction');
  });

  it('formats points with bold label', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'point', text: 'God loves us' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('- **Point:** God loves us');
  });

  it('formats notes with italic label', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'note', text: 'Personal story here' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('- *Note:* Personal story here');
  });

  it('formats scripture with reference and optional note', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'scripture', reference: 'John 3:16', note: 'Key verse' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('- **Scripture:** John 3:16 — Key verse');
  });

  it('formats scripture without note when note is empty', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'scripture', reference: 'Romans 8:28' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('- **Scripture:** Romans 8:28');
    expect(md).not.toContain('—');
  });

  it('formats hymns with title and optional note', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'hymn', hymnId: 'hymn-1', title: 'Amazing Grace', note: 'All verses' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    expect(md).toContain('- **Hymn:** Amazing Grace — All verses');
  });

  it('includes footer attribution', () => {
    const md = exportToMarkdown([], 'Test');

    expect(md).toContain('Elder-First Church Platform');
  });

  it('preserves element order in output', () => {
    const elements: SermonElement[] = [
      { id: 'test-1', type: 'section', title: 'Intro' },
      { id: 'test-2', type: 'point', text: 'First Point' },
      { id: 'test-3', type: 'scripture', reference: 'John 1:1' },
      { id: 'test-4', type: 'section', title: 'Conclusion' },
    ];

    const md = exportToMarkdown(elements, 'Test');

    const introIndex = md.indexOf('### Intro');
    const pointIndex = md.indexOf('First Point');
    const scriptureIndex = md.indexOf('John 1:1');
    const conclusionIndex = md.indexOf('### Conclusion');

    expect(introIndex).toBeLessThan(pointIndex);
    expect(pointIndex).toBeLessThan(scriptureIndex);
    expect(scriptureIndex).toBeLessThan(conclusionIndex);
  });

  it('handles empty elements array', () => {
    const md = exportToMarkdown([], 'Empty Sermon');

    expect(md).toContain('# Empty Sermon');
    expect(md).toContain('## Sermon Outline');
    expect(md).toContain('Elder-First Church Platform');
  });
});

describe('SermonHelperOutline - Type Guards', () => {
  it('correctly identifies section type', () => {
    const element: SermonElement = { id: 'test', type: 'section', title: 'Test' };

    expect(element.type === 'section').toBe(true);
    if (element.type === 'section') {
      expect(typeof element.title).toBe('string');
    }
  });

  it('correctly identifies hymn type with hymnId', () => {
    const element: SermonElement = {
      id: 'test',
      type: 'hymn',
      hymnId: 'hymn-123',
      title: 'Amazing Grace',
    };

    expect(element.type === 'hymn').toBe(true);
    if (element.type === 'hymn') {
      expect(element.hymnId).toBe('hymn-123');
    }
  });
});
